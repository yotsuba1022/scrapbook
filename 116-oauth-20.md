# Securing REST Services

傳統的web application如果有security上的需求, 最典型的不外乎就是要求使用者輸入username/password, 然而, 對REST service來說, 這可能會有一些地方要考量. 我們知道, REST service的客戶端可以很多樣化, 從瀏覽器到行動裝置, 甚至來呼叫API的還可能是一個非人類個體\(machine-to-machine communication\), 而客戶端代替使用者呼叫REST service其實也是很常見的.

這邊我會介紹以下幾種用來保護REST service的手段, 有些部分會開專章來寫:

* Session-based security
* HTTP Basic Authentication
* Digest Authentication
* Certificate based security
* XAuth
* OAuth

#### Session-based Security

Session-based基本上是依賴server side session在往來的request之間保持使用者的identity. 在傳統的web application中, 使用者通常都要成功通過login page才可以存取受保護的資源. 成功登入的使用者, 其資訊會被server保存在HTTP session之中, 而在使用者之後與server的互動\(request\)之中, 也會透過查詢session去嘗試獲取使用者的資訊, 確認是否是合法授權\(authorization\)的使用者. 若使用者不具備合法授權身份, 則拒絕request.

以下是Session-based的圖形流程:

這種做法看起來不錯, 但在RESTful的原則中, 這種做法違反了**statelessness**這一點; 同時, 由於server hold住了client的狀態\(state\), 所以這種作法基本上很難做到scalable. 在理想的情境下, client應該hold住自己的狀態且server應該要是無狀態的.

#### HTTP Basic Authentication

我們知道透過login表單可以獲取使用者的username/password, 然而, 對於service之間互相溝通的狀況, 這種作法基本上是不可行的\(因為兩邊都不是人類\). HTTP basic authentication提供了一種不論是在互動式\(interactive\)或非互動式\(noninteractive\)的情境下都可以由client送出認證資訊\(authentication information\)的機制.

在這種機制中, 當client送出針對受保護資源的請求時, 會先收到一個**401"Unauthorized"**的回應, 其中還帶著一個"WWW-Authenticate"的header, 該header的值會有一個"Basic"區塊, 表示我們要使用Basic authentication, 而緊接在後的"realm"區塊則指出了server上的受保護區塊:

```
GET /protected_resource

401 Unauthorized

WWW-Authenticate: Basic realm="Example Realm"
```

在收到了這個response之後, client會先把username跟password透過一個"; \(semicolon\)"串起來\(concatenate\), 然後再將這個串好的字串用Base64編碼\(encode\)過. 最後透過標準的Authorization header把這些資訊送到server.

```
GET /protected_resource
Authorization: Basic bHxpY26U5lkjfdk
```

而server收到後就會去decode這些資訊並且驗證其中的credentials, 若通過的話, server就會幫忙處理這個request.

簡單的流程圖如下:

這種機制看來是可以讓server達到stateless了, 然而, 你應該可以看得出來, client只是對credentials進行編碼\(encode\), 並不是加密\(encrypt\), 所以在non-SSL/TLS connection的環境下, 是可能遭受到main-in-the-middle attack的, 然後password可能就會被偷走了.

#### Digest Authentication

這跟Basic authentication很相似, 不過user credentials是有加密的. 當client送出針對受保護資源的請求時, 會收到如下的response:

```
GET /protected_resource
401 Unauthorized
WWW-Authenticate: Digest realm="Example Realm", nonce="P35kl89sdfghERT10Asdfnbvc", qop="auth"
```

注意到了嗎? 在"WWW-authenticate"裡面指定的是"Digest" authentication, 不是像前面討論的"Basic", 而nonce則是一個隨機的token, 是之後要用來加密的. 至於qop, 其原意為"quality of protection", 通常會有兩種值: "auth"以及"auth-int".

* qop "auth": 表示這個digest的目的是用來作authentication的
* qop "auth-int": 表示這個digest除了用來作authentication, 還要用來確保request integrity

再來, 當client收到response之後, 根據qop的不同, 會產生不同的行為:

qop="auth"的場合

用以下公式生成digest:

```
hash_value_1 = MD5(username:realm:password)

hash_value_2 = MD5(request_method:request_uri)

digest = MD5(hash_value_1:nonce:hash_value_2)
```

qop="auth-int"的場合

用以下公式生成digest\(會包含request body\):

```
hash_value_1 = MD5(username:realm:password)
hash_value_2 = MD5(request_method:request_uri:MD5(request_body))
digest = MD5(hash_value_1:nonce:hash_value_2)
```

預設上會用MD5去算出hash value, 然後算好的digest會被包在"Authorization" header中然後送至server.


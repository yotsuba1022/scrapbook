# Two-Phase-Commit \(a.k.a 2PC\)

#### Two-Phase-Commit

在分布式系統中, 每個節點雖然可以知道自己的操作是成功還是失敗, 卻無法知道其它的節點是成功還是失敗. 當一個transaction跨越了多個節點的時候, 為了保持transaction的ACID特性, 需要引入一個作為**協調者**的元件來統一掌握所有節點\(或稱**參與者**\)的操作結果並最終指示這些節點是否要把操作結果真正的進行commit的動作.

再來, 看一下兩階段各有什麼事情要做:

* 第一階段
  1. 協調者會問所有參與者, 是否可以執行commit操作了
  2. 各個參與者開始transaction執行的準備工作, 如: lock resources, 預留resources, 寫undo/redo log...等
  3. 參與者回覆協調者, 如果transaction的準備工作成功, 則回應"可以commit", 否則回應"拒絕commit"
* 第二階段
  * 如果所有的參與者都回"可以commit", 那麼協調者就向所有的參與者發送"正式commit"的命令. 參與者完成正式commit, 並釋放所有資源, 然後回應"完成", 協調者收集各個節點的"完成"回應後結束這個global transaction
  * 如果有任何一個參與者回覆"拒絕commit", 那麼協調者向所有的參與者發送"rollback操作", 則參與者們釋放所有資源, 然後回應"rollback完成", 協調者收集各節點的"rollback"回應後, 取消這個global transaction

所以你可以看到, 2PC其實就是種第一階段投票, 第二階段做決定的演算法, 且基本上是強一致性的. 這個比Master-Slave的強一致性策略還要更保守一些\(先嘗試再commit\). 在一些系統設計中, 會串連一系列的呼叫, 譬如: A-&gt;B-&gt;C-&gt;D, 每一步都會分配一些資源或改寫一些資料. 舉個例子, 在B2C網站購物的下單操作在後端會有一系列的流程要跑. 如果一步一步的作, 就會出現這樣的問題, 如某一步做不下去了, 那麼前面每一次所分配資源需要作反向操作把它們都回收掉, 所以操作起來比較複雜. 現在很多處理流程\(workflow\)都會借鑑2PC這個演算法, 使用try-&gt;confirm的流程來確保整個流程能夠成功完成.


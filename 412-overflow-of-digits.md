# Overflow of Digits

在處理數字的時候, 有一個很重要的議題是要處理溢位\(overflow\)問題, 首先, 先來看一下若是在32位元的情境下, 我們對10進位整數的基本定義:

* **32-bit unsigned integer**: 即32-bit無號整數, 其範圍是 0 ~ \(2^32\)-1, 即 0~4,294,967,295 
  -&gt; \(2^32\)-1中, -1的原因是因為我們要從0開始算, 而非從1開始.

* **32-bit signed integer**: 即32-bit有號整數, -\(2^31\) ~ \(2^31\)-1, 即 -2,147,483,648 ~ 2,147,483,647
  -&gt; 這邊是31次方而不是32次方是因為有號\(signed\)整數要同時紀錄正/負數的範圍, 其會各佔掉一半的空間, 所以相較於無號整數, 其最大值只有一半而已\(即少了2的一次方\), 上限-1的原因也是一樣要包含0.

### 關於Overflow

有了前面的定義, 我們就可以來看overflow了, 在32-bit的作業系統上, 記憶體只能記錄上述範圍的數字, 若超過了這個範圍, 記憶體就無法正常處理了, 這就是所謂的overflow. 這邊用簡單的例子來看一下overflow的特性:

* 32-bit signed integer overflow:
  * 2,147,483,647 + 1 = -2,147,483,648
    由於前者已經是最大值了, 所以這時候若再+1, 會繞一圈回到最小值.

  * -2,147,483,648 - 2 = 2,147,483,646
    同前一個情況, 你如果把最小值拿來-1, 就會繞回最大值, -2就會是最大值-1.



